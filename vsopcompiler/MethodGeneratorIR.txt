//
// Created by Julien L'hoest on 14/05/19.
//

#ifndef COMPILER_CODEGENERATOR_HH
#define COMPILER_CODEGENERATOR_HH

#include <string>

#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/STLExtras.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Verifier.h>


static llvm::LLVMContext TheContext;
static llvm::IRBuilder<> Builder(TheContext);
static std::unique_ptr<llvm::Module> TheModule = llvm::make_unique<llvm::Module>("TODOPutCorrectFileName", TheContext);
static std::map<std::string, llvm::AllocaInst *> NamedValues;
static std::map<std::string, llvm::StructType *> ClassesType;

// Because in vsop, every variable have a default initial value TODO Check if this is true for Class types (fields should be initialized by default)
// @args Variable's type, Variable's value, Variable's name.
static llvm::AllocaInst* CreateEntryBlockAlloca(llvm::Type* VarType, llvm::Value* VarValue , const std::string &VarName) {

    // TODO If needed, add Block argument to allocate memory where they are declared instead of function entry
    llvm::IRBuilder<> TmpB(Builder.GetInsertBlock(), Builder.GetInsertBlock()->begin());

    return TmpB.CreateAlloca(VarType, 0, VarValue, VarName.c_str());
}


class CodeGenerator 
{
public:
    llvm::Value* visit(ASTnode *);
    llvm::Value* visit(Expr *);
    llvm::Value* visit(Type *);
    llvm::Value* visit(Field *);
    llvm::Value* visit(Formal *);
    llvm::Value* visit(Formalx *);
    llvm::Value* visit(Formals *);
    llvm::Value* visit(Exprx *);
    llvm::Value* visit(Exprxx *);
    llvm::Value* visit(Block *);
    llvm::Value* visit(Method *);
    llvm::Value* visit(FieldMethod *);
    llvm::Value* visit(Body *);
    llvm::Value* visit(Classe *);
    llvm::Value* visit(Classes *);
    llvm::Value* visit(Programm *);
    llvm::Value* visit(Dual *);
    llvm::Value* visit(Unary *);
    llvm::Value* visit(If *);
    llvm::Value* visit(While *);
    llvm::Value* visit(Let *);
    llvm::Value* visit(Assign *);
    llvm::Value* visit(Not *);
    llvm::Value* visit(And *);
    llvm::Value* visit(Equal *);
    llvm::Value* visit(Lower *);
    llvm::Value* visit(LowerEqual *);
    llvm::Value* visit(Plus *);
    llvm::Value* visit(Minus *);
    llvm::Value* visit(Times *);
    llvm::Value* visit(Div *);
    llvm::Value* visit(Pow *);
    llvm::Value* visit(Minus1 *);
    llvm::Value* visit(IsNull *);
    llvm::Value* visit(Args *);
    llvm::Value* visit(Function *);
    llvm::Value* visit(Dot *);
    llvm::Value* visit(New *);
    llvm::Value* visit(ObjID *);
    llvm::Value* visit(Literal *);
    llvm::Value* visit(IntLit *);
    llvm::Value* visit(StrLit *);
    llvm::Value* visit(BoolLit *);
    llvm::Value* visit(Lpar *);
    llvm::Value* visit(Rpar *);
    llvm::Value* visit(Parenthese *);
};


#endif //COMPILER_CODEGENERATOR_HH
